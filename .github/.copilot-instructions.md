# GitHub Copilot Instructions for P-Type Project

## Code Quality Standards

### No Placeholders or TODOs
- **NEVER** use placeholder code, comments like `// TODO`, `// FIXME`, or incomplete implementations
- **NEVER** use comments like `...existing code...`, `// Add more logic here`, or `// Implementation needed`
- All code must be fully implemented, tested, and production-ready
- Every function, component, and module must be complete and functional

### No Workarounds or Shortcuts
- **NEVER** use temporary workarounds or "quick fixes"
- **NEVER** simplify complex logic just to get something working faster
- Implement proper solutions that handle all edge cases
- Use appropriate design patterns and best practices
- Handle errors gracefully with proper error boundaries and try-catch blocks
- Implement proper loading states, error states, and empty states

### Strict TypeScript
- **ALWAYS** use TypeScript with strict mode enabled
- **NEVER** use `any` type - use proper type definitions or `unknown` with type guards
- **ALWAYS** define proper interfaces and types for all data structures
- **ALWAYS** use proper type guards and type narrowing
- **ALWAYS** handle nullable/undefined values explicitly
- Use generic types where appropriate for reusability
- Export all types and interfaces that may be reused
- Use discriminated unions for complex state management
- Properly type all React components, hooks, and event handlers

### Production-Ready Code
- Code must be:
  - **Robust**: Handle all edge cases, errors, and failure scenarios
  - **Feature-rich**: Implement all features completely, not basic versions
  - **Performant**: Optimize for performance, avoid unnecessary re-renders
  - **Accessible**: Include proper ARIA labels and keyboard navigation
  - **Tested**: Write code that is easily testable
  - **Maintainable**: Use clear naming, proper structure, and documentation
  - **Secure**: Validate inputs, sanitize data, prevent XSS/injection

### Error Handling
- **ALWAYS** implement comprehensive error handling
- **NEVER** let errors silently fail or show raw error messages to users
- Use error boundaries for React components
- Implement proper try-catch blocks for async operations
- Provide user-friendly error messages
- Log errors appropriately for debugging
- Implement retry logic where appropriate
- Handle network failures and timeouts

## Visual Design Standards

### Unified Theme
All UI components, pages, modals, and interactive elements MUST share the unified theme from the title page:

#### Color Palette
```typescript
// Primary Colors
const NEON_GREEN = '#00ff88';
const NEON_BLUE = '#00d4ff';
const NEON_PINK = '#ff0088';
const NEON_PURPLE = '#8800ff';

// Background Colors
const DARK_BG = 'rgba(10, 14, 27, 0.95)';
const DARKER_BG = 'rgba(5, 7, 13, 0.98)';
const CARD_BG = 'rgba(15, 20, 35, 0.95)';

// Accent Colors
const ACCENT_CYAN = '#00ffff';
const ACCENT_ORANGE = '#ff8800';
const ACCENT_YELLOW = '#ffff00';

// Text Colors
const TEXT_WHITE = '#ffffff';
const TEXT_GRAY = '#a0aec0';
const TEXT_DIM = '#718096';
```

#### Visual Effects
- **Glow Effects**: All interactive elements should have neon glow on hover/focus
  - Box shadow with color spread: `0 0 20px rgba(0, 255, 136, 0.6)`
  - Text shadow for glowing text: `0 0 10px rgba(0, 255, 136, 0.8)`
- **Borders**: 2px solid with neon colors and transparency
  - Default: `2px solid rgba(0, 255, 136, 0.4)`
  - Hover: `2px solid rgba(0, 255, 136, 0.8)`
- **Gradients**: Use dark gradients for backgrounds
  - `linear-gradient(135deg, rgba(10,14,27,0.95) 0%, rgba(15,20,35,0.95) 100%)`
- **Transitions**: Smooth transitions on all interactive elements
  - `transition: all 0.3s ease`
- **Hover States**: Scale and glow effects
  - `transform: scale(1.02)` or `scale(1.05)` for buttons
  - Increased glow intensity

#### Typography
- **Headings**: Bold, uppercase, with text shadow and neon color
  - Font weight: 700 or bold
  - Letter spacing: 0.1em
  - Text transform: uppercase
- **Body Text**: Clean, readable with sufficient contrast
  - Color: #ffffff or #a0aec0
  - Line height: 1.6
- **Monospace**: For code and technical content
  - Font family: 'Monaco', 'Courier New', monospace

#### Component Patterns
- **Buttons**: 
  - Rounded corners (border-radius: 8px)
  - Padding: 12px 24px
  - Neon border and background
  - Glow on hover
  - Scale transform on hover
  - Disabled state with reduced opacity and no interaction
  
- **Cards**:
  - Dark background with transparency
  - Neon border
  - Subtle inner glow
  - Smooth hover transitions
  
- **Modals**:
  - Dark overlay background
  - Centered card with theme styling
  - Close button with neon accent
  - Smooth fade-in animation
  
- **Forms**:
  - Input fields with dark background
  - Neon border that glows on focus
  - Clear labels with proper spacing
  - Validation states (error/success) with appropriate colors
  
- **Dropdowns/Selects**:
  - Consistent with form inputs
  - Neon accent on selected items
  - Smooth expand/collapse animations

### 3D Scene Design
- **Consistent Lighting**: Use ambient and directional lights consistently
- **Color Scheme**: Match 3D object colors to the UI theme (neon accents)
- **Camera Movement**: Smooth lerp-based transitions
- **Particle Effects**: Use theme colors for particles and effects
- **Text in 3D**: Use drei Text with emissive materials matching theme colors

## Project Structure Standards

### File Organization
- Group related functionality in directories
- Use index files for clean exports
- Separate concerns: components, utils, hooks, types, stores
- Keep files focused and under 300 lines when possible

### Component Structure
```typescript
// 1. Imports (grouped: React, third-party, local)
import { useState, useEffect } from 'react';
import { useThree } from '@react-three/fiber';
import { useGameStore } from '../store/gameStore';

// 2. Type definitions
interface ComponentProps {
  prop: string;
  // ... all props with proper types
}

interface ComponentState {
  // ... internal state types
}

// 3. Constants (outside component for performance)
const CONSTANT_VALUE = 100;

// 4. Component
export function Component({ prop }: ComponentProps) {
  // 4a. Hooks (in consistent order)
  const [state, setState] = useState<ComponentState>({});
  const store = useGameStore();
  
  // 4b. Effects
  useEffect(() => {
    // Complete implementation
  }, []);
  
  // 4c. Event handlers
  const handleEvent = () => {
    // Complete implementation with error handling
  };
  
  // 4d. Render helpers
  const renderHelper = () => {
    // Complete implementation
  };
  
  // 4e. Return JSX
  return (
    <div>
      {/* Complete, accessible markup */}
    </div>
  );
}
```

### State Management
- Use Zustand for global state
- Keep component-local state when appropriate
- Avoid prop drilling - use context or global state
- Implement proper state updates (immutable patterns)
- Type all store slices completely

### Performance
- Use React.memo for expensive components
- Implement proper dependency arrays in useEffect/useCallback
- Use useCallback for event handlers passed as props
- Optimize Three.js scenes (instancing, LOD, frustum culling)
- Lazy load routes and heavy components
- Implement proper loading states

## Testing Standards
- Write testable code with proper separation of concerns
- Mock external dependencies properly
- Test error scenarios and edge cases
- Test async operations with proper await patterns

## Documentation Standards
- Document complex algorithms and business logic
- Use JSDoc comments for public APIs
- Include examples in documentation
- Keep documentation up-to-date with code changes
- Document breaking changes and migrations

## Git Standards
- Write clear, descriptive commit messages
- Use conventional commit format
- Keep commits focused and atomic
- Write meaningful PR descriptions

## React Three Fiber Specific

### Scene Organization
- Group related 3D objects in components
- Use proper lighting for all scenes
- Implement proper camera controls
- Handle window resize properly
- Clean up resources in useEffect cleanup

### Performance
- Use instancing for repeated geometry
- Implement proper LOD (Level of Detail)
- Use `frustumCulled` appropriately
- Dispose of geometries and materials properly
- Use `useFrame` selectively

### Type Safety
- Type all Three.js objects properly
- Use proper refs with typed Three.js objects
- Type all mesh, geometry, and material props

## Security Standards
- Validate all user inputs
- Sanitize data before rendering
- Use proper CORS policies
- Implement rate limiting where needed
- Keep dependencies updated
- Never commit secrets or API keys

## Accessibility Standards
- Implement proper ARIA labels
- Ensure keyboard navigation works
- Maintain proper color contrast ratios
- Provide alternative text for images
- Make interactive elements focusable
- Support screen readers

## Remember
Every piece of code you write represents the final, production-ready version. There are no "iterations" or "improvements to be made later". It must be complete, robust, and feature-rich from the start.
